<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="enhancing-xv6-os">Enhancing xv6 OS</h1>
<h2 id="sriram-devata-2019113007">Sriram Devata (2019113007)</h2>
<h2 id="introduction">Introduction</h2>
<p>Run xv6 with the command:</p>
<pre class="hljs"><code><div>make qemu
</div></code></pre>
<p>The default scheduling mechanism is Round Robin. To use any of the other scheduling mechanisms, pass the compile-time flag <code>SCHEDULER</code> with the command:</p>
<pre class="hljs"><code><div>make qemu SCHEDULER={RR,FCFS,PBS,MLFQ}
</div></code></pre>
<p>This version of xv6 has the following additions on top of the current version of xv6:</p>
<ul>
<li>Scheduling mechanisms - implemented FCFS, PBS, and MLFQ</li>
<li><code>strace</code>: a syscall to keep track of particular syscalls that a process makes</li>
<li>Added more information to <code>procdump</code></li>
<li><code>waitx</code>: a syscall similar to <code>wait</code>, but also gives the time spent running and waiting for a child process</li>
<li><code>time</code>: a user program to calculate the runtime and wait time of a command</li>
<li><code>schedulertest</code>: a user program to schedule a combination of IO-bound and CPU-bound programs to test the schedulers</li>
</ul>
<h2 id="specification-1-syscall-tracing-with-strace">Specification 1: Syscall tracing with <code>strace</code></h2>
<p>A user program <code>strace mask command [args]</code> uses the syscall <code>strace</code> to print the syscall information whenever the set of syscalls encoded into <em>mask</em> are called by the <em>command</em>.</p>
<p>An attribute <code>mask</code> is stored in each <code>struct proc</code>.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> {</span>
    ...
    <span class="hljs-keyword">int</span> mask;
    ...
}
</div></code></pre>
<p>When the syscall <code>strace</code> is called, it sets the <code>mask</code> attribute of the <code>myproc()</code>, i.e. the current process.</p>
<pre class="hljs"><code><div><span class="hljs-function">uint64
<span class="hljs-title">sys_strace</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    ...
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> = <span class="hljs-title">myproc</span>();</span>
    ...
    p-&gt;mask = mask;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>Since <code>strace</code> enables the printing of syscall for a process and all of its children, a child process formed by <code>fork()</code> should get the mask of its parent.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    ...
    <span class="hljs-comment">// copy the strace mask to the child</span>
    np-&gt;mask = p-&gt;mask;
    ...
}
</div></code></pre>
<p>When a syscall is handled in <code>syscall.c</code>, if the process has a non-zero mask, the information of the syscall is printed when the syscalls encoded in the process's mask are called.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    ...
    <span class="hljs-keyword">if</span> (p-&gt;mask &amp; (<span class="hljs-keyword">int</span>)<span class="hljs-number">1</span>&lt;&lt;num) {
        <span class="hljs-built_in">printf</span>(...);
    }
    ...
}
</div></code></pre>
<h2 id="specification-2-scheduling-mechanisms">Specification 2: Scheduling Mechanisms</h2>
<p>The default scheduler in xv6 is Round Robin. This version of xv6 has other non-default schedulers that can be set at compile time with the flag <code>SCHEDULER</code>.</p>
<h3 id="fcfs---first-come-first-served">FCFS - First Come First Served</h3>
<p>The scheduler takes the <em>RUNNABLE</em> process that came first, and runs it till the process finishes.</p>
<p>Struct proc stores the time of creation in <code>ctime</code>, and it is set to 0 in <code>allocproc()</code>.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> {</span>
    ...
    uint ctime;
    ...
}
</div></code></pre>
<p>The <code>scheduler()</code> finds the <em>RUNNABLE</em> process with the lowest <code>ctime</code>, and runs that process.</p>
<pre class="hljs"><code><div>      <span class="hljs-keyword">for</span>(p = &amp;proc[<span class="hljs-number">0</span>]; p &lt; &amp;proc[NPROC]; p++) {
        <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) {
          <span class="hljs-keyword">if</span>(first_proc == <span class="hljs-literal">NULL</span>) {
            first_proc = p;
          }
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first_proc-&gt;ctime &gt; p-&gt;ctime) {
            first_proc = p;
          }
        }
      }

      <span class="hljs-keyword">if</span> (first_proc != <span class="hljs-literal">NULL</span> &amp;&amp; first_proc-&gt;state == RUNNABLE) {
          ...
      }
</div></code></pre>
<p>Once chosen, a process should not <em>yield</em> until it finishes running. In <code>trap.c</code>, the process yields if the macro <code>FCFS</code> is not defined.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">usertrap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined FCFS</span>
    ...
        <span class="hljs-built_in">yield</span>();
    ...
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">kerneltrap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined FCFS</span>
    ...
        <span class="hljs-built_in">yield</span>();
    ...
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}
</div></code></pre>
<h3 id="pbs---priority-based-scheduler">PBS - Priority Based Scheduler</h3>
<p>The scheduler chooses the process with the highest priority.</p>
<p>The process now also has the following information:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> {</span>
    ...
    uint num_scheduled;
    uint s_priority;
    <span class="hljs-keyword">int</span> nice;
    uint stime;
    uint rtime_ls;
    ...
}
</div></code></pre>
<p><code>stime</code> and <code>rtime_ls</code> are the times the process spent sleeping and the time spent running from the last time it was scheduled. <code>num_scheduled</code> is the total number of times that the process has been scheduled.</p>
<p>Each process has a default static priority of 60. The syscall <code>setpriority</code> can change the static priority of a process. The dynamic priority of the process is calculated from the static priority and the nice value while scheduling. As soon as a process is scheduled, its nice values are updated in <code>update_process</code>.</p>
<p>Since this is a non-preemptive PBS, the process does not yield in <code>usertrap</code> and <code>kerneltrap</code>.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">usertrap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined PBS</span>
    ...
        <span class="hljs-built_in">yield</span>();
    ...
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">kerneltrap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined PBS</span>
    ...
        <span class="hljs-built_in">yield</span>();
    ...
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}
</div></code></pre>
<p>If multiple processes have the same priority, the tie is broken with the number of times they were scheduled, and the creation time of the process.</p>
<h3 id="mlfq---multi-level-feedback-queue">MLFQ - Multi Level Feedback Queue</h3>
<p>There are 5 priority queues where the timer tick quotas for each are 1, 2, 4, 8, 16. <code>mlfq_q</code> has the priority queues, and <code>procs_q</code> stores the number of processes in that queue. Each process also stores the queue it is in, in <code>struct proc-&gt;q_num</code>.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">mlfq_q</span>[5][<span class="hljs-title">NPROC</span>];</span>
uint max_q_ticks[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>};
uint procs_q[<span class="hljs-number">5</span>] = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
</div></code></pre>
<p>The functions <code>remove_p_from_q</code> and <code>add_p_to_q</code> remove and add processes to the priority queues.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove_p_from_q</span><span class="hljs-params">(struct proc *p)</span></span>{
    ...
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add_p_to_q</span><span class="hljs-params">(struct proc *p, <span class="hljs-keyword">int</span> q_no)</span></span>{
    ...
}
</div></code></pre>
<p>At the start of each scheduling round, the processes whose wait times are above <code>AGE_LIMIT</code> are moved to the higher priority queue.</p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q_no = <span class="hljs-number">1</span>; q_no &lt; <span class="hljs-number">5</span>; q_no++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p_no = <span class="hljs-number">0</span>; p_no &lt; procs_q[q_no]; p_no++){
            <span class="hljs-keyword">if</span> (mlfq_q[q_no][p_no]-&gt;<span class="hljs-keyword">age_t</span> &gt; AGE_LIMIT){
                ...
            }
        }
    }
</div></code></pre>
<p>The processes are allowed to run according to the quota of time limit they have based on the priority queue they are in. The processes yield in <code>usertrap</code> and <code>kerneltrap</code> only if they have exhausted their limit.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">usertrap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> MLFQ</span>
  <span class="hljs-keyword">if</span> (which_dev == <span class="hljs-number">2</span> &amp;&amp; p-&gt;rtime_ls &gt;= max_q_ticks[p-&gt;q_num]) {
    ...
    <span class="hljs-built_in">yield</span>();
  }
  <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">kerneltrap</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> MLFQ</span>
  <span class="hljs-keyword">if</span> (which_dev == <span class="hljs-number">2</span> &amp;&amp; p != <span class="hljs-number">0</span> &amp;&amp; p-&gt;state == RUNNING
     &amp;&amp; p-&gt;rtime_ls &gt;= max_q_ticks[p-&gt;q_num]) {
    ...
    <span class="hljs-built_in">yield</span>();
  }
  <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}
</div></code></pre>
<p>The round robin in the lowest priority queue is implemented implicitly since whenever the process in any priority queue exhausts its ticks limit, it is removed from the present queue and added to the next lower priority queue. If it is already in the lowest priority queue, it is added to the end of the lowest priority queue.</p>
<p>When a process gives up control of the CPU on its own, it leaves the queuing network and then reenters at the tail end of the same queue. If a process knows the quota of ticks in each priority queue, it can exploit this by using upto 99% of its allocated time and then give up the CPU. This makes sure that the process stays in the same high priority queue.</p>
<h3 id="testing-the-schedulers">Testing the schedulers</h3>
<p>The user program <code>schedulertest</code> will run fork multiple child processes and prints when the processes are done, along with the average run time and average wait time.</p>
<h3 id="analysis">Analysis</h3>
<p>With the userprogram <code>schedulertest</code> (the output might be weird if there are multiple <code>CPU</code>s), the default test results for the different scheduling mechanisms for 1 CPU are:</p>
<table>
<thead>
<tr>
<th>Scheduler</th>
<th>Average Run Time</th>
<th>Average Wait Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>RR</td>
<td>42</td>
<td>269</td>
</tr>
<tr>
<td>FCFS</td>
<td>85</td>
<td>382</td>
</tr>
<tr>
<td>PBS</td>
<td>44</td>
<td>312</td>
</tr>
<tr>
<td>MLFQ</td>
<td>39</td>
<td>332</td>
</tr>
</tbody>
</table>
<h2 id="specification-3-adding-details-to-procdump">Specification 3: Adding details to <code>procdump</code></h2>
<p><code>procdump</code> in <code>proc.c</code> has the relevant information printed for the different schedulers.</p>
<h3 id="mlfq-scheduling-analysis">MLFQ Scheduling Analysis</h3>
<p>After printing the queue of all processes in <code>update_time</code>, the output was stored by <code>script</code> and plotted using a python script.</p>
<p><img src="MLFQ_Plot.png" alt="MLFQ Plot"></p>

</body>
</html>
